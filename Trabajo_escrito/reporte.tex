\documentclass[12pt]{article}
\usepackage{enumitem}

\usepackage[left=25mm, right=25mm, top=25mm, bottom=25mm, headheight=25mm]{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage{subfig} % Poder colocar más de una imagen en una {Figura}
\usepackage[figurename=Imagen]{caption} % Cambiar la descripción de la Image 
\usepackage[utf8]{inputenc} % Idioma español
\usepackage[spanish]{babel} % Idioma español

% Para poder ajustar los colores en las referencias que se hagan
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor = black,
    citecolor = blue,
    urlcolor = blue
}

% Dar formato a las páginas y colocar el \rfoot{De forma que nos interese}
\usepackage{parskip}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{fancyhdr}
\pagestyle{fancy}
\cfoot{}
\rfoot{Página \thepage\ de \pageref{LastPage}}
\rhead{}
\lhead{}
\renewcommand{\headrulewidth}{0pt}

% Parámetros que pueden cambiar ----------------------------------------------------------------------------
% Nombres
\newcommand{\Profesor}{Profesor: Edgar Tista García}
\newcommand{\Materia}{Asignatura: Estructura de Datos y Algoritmos II}
\newcommand{\Grupo}{Grupo:  5}
\newcommand{\Nombre}{Integrantes: Martínez Trinidad Alexis, Vázquez Flores José Angel, Zarate Menes Quetzalli}
\newcommand{\NoLista}{No. de lista: 22, 30, 35}
\newcommand{\Proyecto}{PROYECTO \#2 - ÁRBOLES BINARIOS }
\newcommand{\Semestre}{Semestre: 2024-2}
\newcommand{\Fecha}{Fecha de entrega: 25 de mayo del 2024}
\newcommand{\Observaciones}{Observaciones:}
\newcommand{\Calificacion}{CALIFICACIÓN:}

\newcommand{\TituloP}{TRABAJO ESCRITO DEL PROYECTO }
\newcommand{\Titulo}{\Proyecto\\\TituloP}


\begin{document}
\begin{center}
    \LARGE\textbf{\TituloP}\par\vspace{0.7cm}
\end{center}
\Large{\Proyecto}\par\vspace{0.6cm}
\Large{\Profesor}\par\vspace{0.6cm}
\Large{\Materia}\par\vspace{0.6cm}
\Large{\Grupo}\par\vspace{0.6cm}
\Large{\Nombre}\par\vspace{0.6cm}
\Large{\NoLista}\par\vspace{0.6cm}
\Large{\Semestre}\par\vspace{0.6cm}
\Large{\Fecha}\par\vspace{0.6cm}
\Large{\Observaciones}\par\vspace{0.6cm}

\begin{center}
    \Large{\Calificacion}\par\vspace{0.6cm}
\end{center}
% -------------------------------------------------------- Empieza el desarrollo de la práctica

\newpage
\section*{\textcolor{red}{\textbf{OBJETIVO}}}
\par\vspace{0.4cm}
Que el alumno implemente aplicaciones relacionadas con los árboles binarios y que desarrolle sus habilidades de trabajo en equipo y programación orientada a objetos. 
\par\vspace{1.5cm}
\section*{\textcolor{red}{\textbf{INTRODUCCIÓN}}}
En el mundo de la programación, las estructuras de datos son como los cimientos de una casa: organizan y mantienen la información de manera eficiente. Entre las más útiles y comunes están los árboles binarios, que representan relaciones jerárquicas como las ramas de un árbol.
\par\vspace{0.4cm}
Este proyecto busca crear un programa que explore las aplicaciones de los árboles binarios. El programa permitirá trabajar con tres tipos:
\par\vspace{0.4cm}
Árboles AVL: Son árboles binarios de búsqueda que se mantienen ''equilibrados'', con una altura similar en ambos lados. Esto los hace rápidos para buscar y agregar información.
\par\vspace{0.4cm}
Árboles Red-Black: Son una variante de los árboles AVL que usan ''colores'' para mantener el equilibrio. Son ideales para aplicaciones que necesitan un comportamiento predecible y eficiente.
\par\vspace{0.4cm}
Árboles de expresión aritmética: Representan operaciones matemáticas como sumas y restas. Permiten evaluar expresiones complejas de forma rápida.
\par\vspace{0.4cm}
El programa tendrá un menú fácil de usar. El usuario podrá elegir el tipo de árbol y la operación que desea realizar, como agregar, buscar, eliminar elementos o resolver expresiones aritméticas. Así, se explorarán las capacidades y ventajas de cada tipo de árbol binario en diferentes situaciones.
\par\vspace{0.4cm}
En resumen, este proyecto creará una herramienta para entender y usar mejor los árboles binarios, estructuras de datos esenciales en la programación.
\par\vspace{0.4cm}

\subsection*{\textcolor{blue}{Algoritmos de inserción y eliminación (para un árbol binario balanceado AVL)}}

Un Árbol AVL es una estructura de datos en forma de árbol binario de búsqueda (BST) que se auto-balancea después de cada inserción o eliminación para mantener su altura mínima posible. El nombre "AVL" proviene de los nombres de los inventores, Adelson-Velsky y Landis.

Características Principales
\begin{itemize}
    \item Auto-balanceo: Después de cada inserción o eliminación, el árbol AVL se reorganiza automáticamente para asegurar que la diferencia de altura entre los subárboles izquierdo y derecho de cada nodo sea como máximo 1.
    
    \item Factor de Balanceo: Cada nodo en un árbol AVL tiene un factor de balance que representa la diferencia de altura entre su subárbol izquierdo y derecho. Este factor debe estar en el rango [-1, 0, 1].

    \item Altura Equilibrada:Un árbol AVL tiene la propiedad de que la altura de sus subárboles en cada nodo difiere en un máximo de 1.
    
    \item Rotaciones:Para mantener el balance, se utilizan rotaciones simples y dobles en los nodos desequilibrados.
    
    \item Eficiencia:Las operaciones de búsqueda, inserción y eliminación tienen una complejidad de tiempo de O(log n) en el peor caso, donde "n" es el número de nodos en el árbol.
\end{itemize}

Funciones Importantes

\begin{itemize}
    \item Inserción:Durante la inserción de un nuevo nodo, se ajusta el balance del árbol mediante rotaciones según sea necesario para mantener la propiedad de AVL.
    
    \item Eliminación:Durante la eliminación de un nodo, se realizan rotaciones para restablecer el balance del árbol mientras se mantiene la propiedad de AVL.

    \item Búsqueda:La búsqueda en un árbol AVL sigue el mismo principio que en un árbol binario de búsqueda estándar, donde se comparan los valores del nodo buscado con los valores en cada nodo del árbol.
    
    \item Rotaciones:Las rotaciones (simple a la derecha, simple a la izquierda, doble izquierda-derecha, doble derecha-izquierda) son operaciones clave utilizadas para reequilibrar el árbol durante las inserciones y eliminaciones.
\end{itemize}


\subsection*{\textcolor{blue}{Algoritmo para la construcción de un árbol de expresión aritmética. }}

Un árbol de expresiones aritméticas en una forma de representar, en forma de estructura de árbol binario, una expresión matemática (operaciones matemáticas).

En este tipo de representaciones hay dos tipos de nodos, nodos operadores y nodos operandos, donde los nodos hoja toman el lugar de los nodos operandos y los demás nodos intermedios el lugar de nodos operadores. En este proyecto se utilizo un árbol binario completo (un árbol en el que cada nodo tiene 0 o 2 hijos) por su facilidad para adaptarse a muchas expresiones aritméticas.

Este tipo de árbol se evalúa, aplicando de manera recursiva, los nodos operadores con los nodos operandos.

Algunas de las aplicaciones de este tipo de estructuras son las siguientes:
\begin{itemize}
    \item Evaluación de expresiones: Los árboles de expresiones se utilizan para evaluar expresiones matemáticas.
    \item Manipulación de expresiones: Los árboles de expresiones permiten manipular matemáticamente las expresiones de una manera estructurada.
    \item Generación de código: En compiladores e intérpretes, los árboles de expresiones se utilizan para generar código.
    \item Visualización de expresiones: Los árboles de expresiones proporcionan una representación visual de las expresiones matemáticas, lo que puede ser útil para la enseñanza y el aprendizaje.
    \item Optimización de expresiones: Los árboles de expresiones pueden ser optimizados para mejorar la eficiencia de la evaluación de la expresión.
\end{itemize}


\subsection*{\textcolor{blue}{Algoritmos de árbol red black }}
El algoritmo de árbol rojo-negro es un método para organizar datos en un árbol binario de búsqueda. Garantiza que el árbol esté equilibrado, lo que significa que las operaciones de búsqueda, inserción y eliminación se pueden realizar en tiempo logarítmico promedio, incluso en el peor de los casos. Esto lo convierte en una estructura de datos eficiente para almacenar y recuperar información.
\par\vspace{0.4cm}
Propiedades de los Árboles Rojo-Negro:
\begin{enumerate}
    \item Cada nodo es rojo o negro.
    \item La raíz es negra.
    \item Todas las hojas (NIL o nodos externos) son negras.
    \item Si un nodo es rojo, entonces ambos hijos son negros (no puede haber dos nodos rojos consecutivos).
    \item Para cada nodo, todos los caminos simples desde ese nodo hasta sus descendientes NIL contienen el mismo número de nodos negros.
\end{enumerate}
Operaciones en Árboles Rojo-Negro:
\par\vspace{0.4cm}
\textbf{Algoritmo de Inserción}
\begin{itemize}
    \item La inserción en un árbol rojo-negro sigue estos pasos generales:
    \begin{itemize}
        \item Inserta el nuevo nodo como en un árbol binario de búsqueda normal, poniéndolo en la posición adecuada según el orden.
        \item Marca el nodo insertado como rojo.
    \end{itemize}
    \item Rebalanceo del árbol:
    \begin{itemize}
        \item Si el nodo insertado es la raíz, se pinta de negro (propiedad 2).
        \item Si el padre del nodo insertado es negro, el árbol sigue siendo un árbol rojo-negro válido.
        \item Si el padre del nodo insertado es rojo, entonces se viola la propiedad 4 y se deben realizar ajustes. Estos ajustes se hacen a través de rotaciones y recoloreos. Hay varios casos que manejar, dependiendo de la estructura del árbol y la posición del nodo insertado.
    \end{itemize}
\end{itemize}
\textbf{Casos de Rebalanceo: Sea z el nodo insertado, p el padre de z, g el abuelo de z y t el tío de z.}
\begin{enumerate}
    \item Caso 1: El padre es negro
    \begin{itemize}
        \item El árbol está balanceado y no se requiere ninguna acción.
    \end{itemize}
    \item Caso 2: El padre es rojo y el tío es rojo: 
    \begin{itemize}
        \item Pinta el padre y el tío de negro.
        \item Pinta el abuelo de rojo.
        \item Repite el proceso desde el abuelo (ahora considerado como el nodo insertado z).
    \end{itemize}
    \item Caso 3: El padre es rojo y el tío es negro o NIL:
    \begin{itemize}
        \item Caso 3a: z es el hijo izquierdo de p y p es el hijo izquierdo de g (o simétricamente):
        \begin{itemize}
            \item Realiza una rotación a la derecha en g.
            \item Intercambia los colores de p y g.
        \end{itemize}
        \item Caso 3b: z es el hijo derecho de p y p es el hijo izquierdo de g (o simétricamente):
        \begin{itemize}
            \item Realiza una rotación a la izquierda en p.
            \item Ahora z es el hijo izquierdo de p.
            \item Aplica el caso 3a.
        \end{itemize}
    \end{itemize}
\end{enumerate}
\textbf{Algoritmo de Eliminación:}
La eliminación de un nodo en un árbol rojo-negro también se realiza en dos fases
\begin{enumerate}
    \item Eliminación
    \begin{itemize}
        \item Encuentra el nodo z que se quiere eliminar.
        \item Si z tiene dos hijos, encuentra el sucesor, intercambia los valores y elimina el sucesor.
        \item Marca el nodo que reemplazará a z como x.
    \end{itemize}
    \item Rebalanceo del Árbol
    \begin{itemize}
        \item Si x o el nodo eliminado son rojos, simplemente se pinta de negro y termina.
        \item Si x y el nodo eliminado son negros, se debe realizar un rebalanceo. Existen varios casos:
        \begin{itemize}
            \item Caso 1: x es la nueva raíz:
            \begin{itemize}
                \item No se requiere ninguna acción adicional.
            \end{itemize}
            \item Caso 2: x tiene un hermano w rojo:
            \begin{itemize}
                \item Intercambia los colores del padre de x y w.
                \item Realiza una rotación en el padre de x y actualiza w.
            \end{itemize}
            \item Caso 3: x tiene un hermano w negro y ambos hijos de w son negros:
            \begin{itemize}
                \item Pinta w de rojo.
                \item Si el padre de x es rojo, se pinta de negro.
                \item Si el padre de x es negro, repite el proceso desde el padre de x.
            \end{itemize}
            \item Caso 4: x tiene un hermano w negro, el hijo izquierdo de w es rojo y el hijo derecho de w es negro:
            \begin{itemize}
                \item Pinta el hijo izquierdo de w de negro y w de rojo.
                \item Realiza una rotación a la derecha en w.
            \end{itemize}
            \item Caso 5: x tiene un hermano w negro y el hijo derecho de w es rojo:
            \begin{itemize}
                \item Intercambia los colores de w y el padre de x.
                \item Pinta el hijo derecho de w de negro.
                \item Realiza una rotación a la izquierda en el padre de x.
                \item Termina.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{enumerate}



\section*{\textcolor{red}{\textbf{ANÁLISIS DEL DESARROLLO DEL PROGRAMA}}}

\subsection*{\textcolor{blue}{Menus.java}}
Los dos programas, Menus.java y Main.java, trabajan en conjunto para proporcionar una interfaz de usuario interactiva para gestionar diferentes tipos de árboles binarios. El programa principal (Main.java) llama un método de la clase Menus y la utiliza para mostrar los menús principales y navegar entre las opciones. A su vez, la clase Menus contiene las funciones para mostrar los menús específicos de cada tipo de árbol y manejar las interacciones del usuario.
\par\vspace{0cm}
Elementos teóricos necesarios:
\begin{itemize}
    \item Estructuras de datos: El código utiliza la estructura de datos "árbol binario" para almacenar y manipular la información. Se implementan tres tipos específicos de árboles binarios:
    \begin{itemize}
        \item Árbol AVL: Un árbol binario auto balanceado que mantiene un equilibrio entre la altura de sus subárboles.
        \item Árbol Red-Black: Otro tipo de árbol binario auto balanceado con propiedades similares al árbol AVL.
        \item Árbol de expresión aritmética: Un árbol binario que representa una expresión aritmética, donde cada nodo contiene un operador o un operando.
    \end{itemize}
    \item Menús interactivos: El código utiliza técnicas de interacción con el usuario para mostrar los menús y capturar las opciones seleccionadas.
\end{itemize}
Estrategia para resolver el problema:
\begin{enumerate}
    \item Diseño de la interfaz de usuario: Se definen los menús principales y los menús específicos para cada tipo de árbol, considerando las opciones disponibles para cada tipo de dato.
    \item Implementación de las funciones de menú: Se desarrollan las funciones para mostrar cada menú y manejar las acciones del usuario, como agregar claves, buscar valores, eliminar claves, mostrar el árbol y resolver expresiones (en el caso del árbol de expresión).
    \item Integración con el programa principal: Se crea una instancia de la clase Menús en el programa principal y se la utiliza para mostrar los menús y navegar entre las opciones.
\end{enumerate}
Avance logrado:
\par\vspace{0cm}
El código proporcionado representa un avance significativo en la implementación de una interfaz de usuario para gestionar diferentes tipos de árboles binarios. Se han diseñado los menús, se ha implementado la lógica para mostrarlos y navegar entre ellos, y se ha esbozado la implementación de las opciones de menú para cada tipo de árbol. Por lo cual en cuanto al menú, consideramos un avance del 100\%.

\subsection*{\textcolor{blue}{Árbol AVL}}
\subsection{\textcolor{blue}{Noda.java}}

\textbf{Atributos:}
\begin{itemize}
    \item \textbf{valor:} Almacena el valor numérico del nodo.
    
    \item \textbf{izq y der:} Referencias al hijo izquierdo y derecho del nodo, respectivamente. Estas referencias apuntan a otros nodos o pueden ser nulas si el nodo no tiene hijos.
\end{itemize}

\textbf{Constructores:}
\begin{itemize}
    \item \textbf{Noda():} Constructor por defecto que inicializa las referencias izq y der como nulas.
    
    \item \textbf{Noda(int data):}Constructor que inicializa el valor del nodo con el valor proporcionado y las referencias izq y der como nulas.
    
     \item \textbf{Noda(int data, Noda lt, Noda rt): }Constructor que permite inicializar el valor del nodo y especificar los nodos hijos izquierdo y derecho.
\end{itemize}

\textbf{Métodos:}
\begin{itemize}
    \item \textbf{setIzq(Noda izq): }Establece el nodo hijo izquierdo.
    
    \item \textbf{setDer(Noda der):}Establece el nodo hijo derecho.
\end{itemize}

\subsection{\textcolor{blue}{ArbolBin1.java}}

\textbf{Atributos:}
\begin{itemize}
    \item \textbf{root:} Es una referencia al nodo raíz del árbol.
    
\end{itemize}

\textbf{Constructores:}
\begin{itemize}
    \item \textbf{ArbolBin1():} Constructor por defecto que inicializa root como nulo.
    
    \item \textbf{ArbolBin1(int val):}Constructor que inicializa el árbol con un nodo raíz que tiene el valor proporcionado.
    
     \item \textbf{ArbolBin1(Noda root): }Constructor que inicializa el árbol con el nodo proporcionado como raíz.
\end{itemize}

\textbf{Métodos:}
\begin{itemize}
    \item \textbf{add(Noda padre, Noda hijo, int lado):}Permite añadir un nodo hijo a un nodo padre en el lado especificado (izquierdo o derecho).
    
    \item \textbf{breadthFrist():}Realiza un recorrido por niveles en el árbol, imprimiendo los valores de los nodos en orden de nivel.

    \item \textbf{eliminar(int valor):}Permite eliminar un nodo del árbol binario según su valor.

    \item \textbf{eliminarRecursivo(Noda nodo, int valor):}Método auxiliar para eliminar un nodo recursivamente.
    
    \item \textbf{encontrarMinimoValor(Nodo nodo):}Encuentra el valor mínimo en un subárbol a partir de un nodo dado.
    
    \item \textbf{buscar(int valor):}Busca un valor específico en el árbol binario.

    \item \textbf{buscarRecursivo(Nodo nodo, int valor): }Método auxiliar para buscar un valor recursivamente en el árbol.
    
\end{itemize}

\subsection{\textcolor{blue}{ArbolBinBusq.java}}

\textbf{Constructores:}
\begin{itemize}
    \item \textbf{ArbolBinBusq():} Constructor por defecto que llama al constructor de la superclase ArbolBin.
    
    \item \textbf{ArbolBinBusq(int val):}Constructor que inicializa el árbol con un nodo raíz que tiene el valor proporcionado.
    
     \item \textbf{ArbolBinBusq(Noda root):}Constructor que inicializa el árbol con el nodo proporcionado como raíz.
\end{itemize}

\textbf{Métodos:}
\begin{itemize}
    \item \textbf{insertar(int valor):}Inserta un nuevo nodo con el valor dado en el árbol binario de búsqueda.
    
    \item \textbf{insertarRecursivo(Nodo nodo, int valor): }Método auxiliar para insertar un nodo de manera recursiva en el árbol binario de búsqueda.

    \item \textbf{buscar(int valor): }Busca un valor específico en el árbol binario de búsqueda.

    \item \textbf{buscarRecursivo(Nodo nodo, int valor):}Método auxiliar para buscar un valor de manera recursiva en el árbol binario de búsqueda.
\end{itemize}

\subsection{\textcolor{blue}{ArbolBBBalanceado.java}}

\textbf{Constructores:}
\begin{itemize}
    \item \textbf{ArbolBBBalanceado():}Constructor por defecto que llama al constructor de la superclase ArbolBinBusq.
    
     \item \textbf{ArbolBBBalanceado(int val):} Constructor que inicializa el árbol con un nodo raíz que tiene el valor proporcionado.
     
     \item \textbf{ArbolBBBalanceado(Nodo root):} Constructor que inicializa el árbol con el nodo proporcionado como raíz.
\end{itemize}

\textbf{Métodos:}
\begin{itemize}
    \item \textbf{insertar(int valor):} Inserta un nuevo nodo con el valor dado en el árbol binario de búsqueda balanceado.
    
    \item \textbf{insertarRecursivo(Nodo nodo, int valor):} Método auxiliar para insertar un nodo de manera recursiva en el árbol binario de búsqueda balanceado.

    \item \textbf{rotarDerecha(Nodo y):} Realiza una rotación a la derecha en el árbol AVL para balancearlo.

    \item \textbf{rotarIzquierda(Nodo x):} Realiza una rotación a la izquierda en el árbol AVL para balancearlo.

    \item \textbf{altura(Nodo nodo):} Calcula la altura de un nodo en el árbol AVL.

    \item \textbf{obtenerBalance(Nodo nodo):} Calcula el factor de balance de un nodo en el árbol AVL.
\end{itemize}

\subsection*{\textcolor{blue}{Árbol Red-Black}}
\subsection{\textcolor{blue}{RedBlackTree.java}}
El programa implementa un Árbol Rojo-Negro (Red-Black Tree) con las siguientes funcionalidades:
\begin{itemize}
    \item \textbf{Insertar clave (insert):} Permite agregar una clave en el árbol, manteniendo las propiedades del Árbol Rojo-Negro.
    \item \textbf{Eliminar clave (deleteNode):} Permite eliminar una clave específica del árbol, también manteniendo las propiedades del Árbol Rojo-Negro.
    \item \textbf{Mostrar árbol (printTree):} Imprime el árbol en la consola, mostrando la estructura y los colores de los nodos.
\end{itemize}



\subsection{\textcolor{blue}{NodeRedBlack.java}}
Define la estructura del nodo del árbol Rojo-Negro. Cada nodo contiene:
\begin{itemize}
    \item \textbf{data:} El valor almacenado en el nodo.
    \item \textbf{parent:} El nodo padre.
    \item \textbf{left:} El hijo izquierdo.
    \item \textbf{right:} El hijo derecho.
    \item \textbf{color:} El color del nodo (0 para negro y 1 para rojo).
\end{itemize}

\subsubsection{Descripción de los Elementos Teóricos}

Un Árbol Rojo-Negro es un tipo de árbol binario de búsqueda autobalanceado con las siguientes propiedades:
\begin{enumerate}
    \item Cada nodo es rojo o negro.
    \item La raíz es negra.
    \item Todas las hojas (TNULL) son negras.
    \item Si un nodo es rojo, entonces ambos hijos son negros.
    \item Para cada nodo, todos los caminos desde el nodo hasta sus hojas descendientes contienen el mismo número de nodos negros.
\end{enumerate}

Estas propiedades aseguran que el árbol se mantenga aproximadamente balanceado, garantizando una complejidad de tiempo \(O(\log n)\) para las operaciones de búsqueda, inserción y eliminación.

\subsubsection{Estrategia para Resolver el Problema}

La estrategia para implementar el Árbol Rojo-Negro se dividió en varios pasos clave:
\begin{enumerate}
    \item \textbf{Definición de la estructura del nodo (Node):} Crear una clase para representar los nodos del árbol, incluyendo la información necesaria y el color.
    \item \textbf{Inicialización del árbol (RedBlackTree):} Implementar el constructor para inicializar el árbol con un nodo nulo (TNULL) que sirve como hoja para todos los nodos.
    \item \textbf{Implementación de las rotaciones (leftRotate y rightRotate):} Estas funciones son cruciales para mantener el balance del árbol durante las inserciones y eliminaciones.
    \item \textbf{Inserción de nodos (insert y fixInsert):} Implementar la inserción de nuevos nodos, seguido de la corrección del árbol para mantener las propiedades del Árbol Rojo-Negro.
    \item \textbf{Eliminación de nodos (deleteNode y fixDelete):} Implementar la eliminación de nodos y la corrección subsecuente del árbol.
    \item \textbf{Impresión del árbol (printTree):} Desarrollar una función para visualizar la estructura y colores del árbol en la consola.
\end{enumerate}

\subsubsection{Principales Dificultades y Soluciones}

\begin{itemize}
    \item \textbf{Mantener las propiedades del Árbol Rojo-Negro:} La mayor dificultad fue asegurarse de que las propiedades del Árbol Rojo-Negro se mantuvieran después de cada inserción y eliminación. Esto se resolvió implementando correctamente las rotaciones y las funciones de corrección (\textit{fixInsert} y \textit{fixDelete}).
    \item \textbf{Manejo de casos especiales durante la eliminación:} El proceso de eliminación es más complejo debido a los diversos casos que pueden surgir (por ejemplo, cuando el nodo a eliminar tiene dos hijos). Se implementaron cuidadosamente los casos especiales y se realizaron pruebas para asegurar la corrección del algoritmo.
    \item \textbf{Visualización del árbol:} Imprimir el árbol de manera que la estructura y los colores fueran claros requirió un manejo cuidadoso de la recursión y los prefijos para representar los niveles y ramas del árbol.
\end{itemize}

\subsubsection{Relación con los Elementos Vistos en Teoría}

Este proyecto está directamente relacionado con los conceptos de árboles binarios de búsqueda, árboles autobalanceados y algoritmos de inserción y eliminación en estructuras de datos. Específicamente, los Árboles Rojo-Negro son un tipo avanzado de árbol binario de búsqueda que garantiza el balance del árbol mediante reglas de color y rotaciones, lo cual es un tema fundamental en cursos de estructuras de datos y algoritmos.

\subsubsection{Avance Logrado de Acuerdo con los Requerimientos}

\begin{itemize}
    \item \textbf{Árbol Red Black Implementado:}
    \begin{itemize}
        \item \textbf{Agregar clave:} Implementado con éxito mediante el método \textit{insert} y la función de corrección \textit{fixInsert}.
        \item \textbf{Eliminar clave:} Implementado con éxito mediante el método \textit{deleteNode} y la función de corrección \textit{fixDelete}.
        \item \textbf{Mostrar árbol:} Implementado con éxito mediante el método \textit{printTree}, que muestra la estructura y colores de los nodos en la consola.
    \end{itemize}
\end{itemize}

En conclusión, se lograron todos los requerimientos solicitados: se implementó un Árbol Rojo-Negro con las funcionalidades de agregar, eliminar y mostrar el árbol, manteniendo las propiedades teóricas y prácticas necesarias para asegurar el balance del árbol.

\subsection*{\textcolor{blue}{Árbol de expresiones aritméticas }}

\subsection{\textcolor{blue}{Clase Nodo.java}}

En esta clase tiene las estructuras de nodos, para el árbol de expresiones aritméticas, como: 
        \begin{itemize}
            \item Crear nodos.
            \item Ver el contenido de los nodos.
            \item Devolver el contenido de un nodo hijo.
        \end{itemize}

\subsection{\textcolor{blue}{Clase ArbolBin.java}}

Esta clase contiene las estructuras necesarias para crea un árbol binario y son las siguiente:
    \begin{itemize}
        \item Como atributo un Nodo raíz.
        \item Dos constructores, uno para inicializar el nodo raíz en null y otro para cambiar el valor del nodo raíz y sus nodos hijos izquierdo y derecho.
        \item Un método que imprime el valor del nodo que recibe por referencia.
        \item El algoritmo de recorrido (para árboles) inOrden.
    \end{itemize}

\subsection{\textcolor{blue}{Clase ConstruirArbol.java}}

Esta clase se podría decir es la más importante para llevar acabo la contrición y resolución del árbol de expresiones aritméticas, contiene lo siguiente:
    \begin{itemize}
        \item El método \verb|construccionArbol| con el cual se construye el árbol usando el algoritmo inOrden y la ayuda de dos pilas (operadores y operandos), las cuales combinan dos valores y un operador para crear un subárbol.
        \item El método \verb|construirSubarbol| este método crea los subárboles con sus nodos operadores y nodos operandos. 
        \item El método \verb|esOperador| que devuelve si un token es, o no, uno de los cuatro operadores (+,-,*,/). 
        \item El método \verb|precedencia| que obtiene la precedencia de los operadores dándole mayor importancia a los operadores de multiplicación y división que a los operadores de suma y resta.
        \item El método \verb|resolverExpresion| resuelve la expresión representada en el árbol iniciando la evaluación desde su nodo raíz.
        \item El método \verb|evaluarExpresionRecursivamente| verifica de manera recursiva la expresión del árbol binario, siguiendo el algoritmo postOrden para su evaluación.
    \end{itemize}

\subsection{\textcolor{blue}{Clase Programa.java}}

Esta clase no es mas que un simple menú que muestra lo que puedes hacer durante su ejecución como:
    \begin{itemize}
        \item Ingresar una expresión u operación aritmética.
        \item Ver el árbol de expresiones aritméticas con el algoritmo de recorrido inOrden.
        \item Evaluar el la expresión.
        \item Salir.
    \end{itemize}



\section*{\textcolor{red}{\textbf{CONCLUSIONES INDIVIDUALES}}}

\subsection*{\textcolor{blue}{Martínez Trinidad Alexis}}

El árbol de expresiones es una estructura de datos muy importantes ya que se pueden resolver operación matemáticas de manera rápida y eficiente, ya que puedes controlar de manera efectiva casos particulares durante la ejecución, como la división entres ceros. 

En otras palabras, aunque haya otras formas de resolver estas operaciones, el árbol de expresiones aritméticas es muy eficaz para su su resolución especialmente en el contexto de la programación y la informática, aun cuando existen métodos como la Notación prefija, infija o la posfija.

\subsection*{\textcolor{blue}{Vázquez Flores José Angel}}

Durante el desarrollo de este proyecto realizamos la implementación de algunos tipos de arboles, como lo son el árbol AVL, Red-Black, de expresiones matemáticas. Además, realizamos la implementación de un menú para manejar y cada uno de ellos. De igual manera, estudiamos y comprendimos de forma satisfactoria la lógica a implementar para cada uno de los arboles implementados. 

Por otra parte, realizamos una buena repartición de la práctica en equipo y realizamos todas las taras de forma satisfactoria, por ende, logramos una buena implementación de los objetivos del proyecto, logrando un buen resultado. 

\subsection*{\textcolor{blue}{Zarate Menes Quetzalli}}
\subsection*{Análisis del Cumplimiento de los Objetivos}

El objetivo principal de la práctica era que el alumno implementara aplicaciones relacionadas con los árboles binarios y desarrollara habilidades de trabajo en equipo y programación orientada a objetos. Este objetivo se cumplió satisfactoriamente por las siguientes razones:

\begin{itemize}
    \item \textbf{Implementación de Árboles Binarios:} Se logró implementar un Árbol Rojo-Negro, un tipo avanzado de árbol binario de búsqueda. Las funcionalidades de inserción, eliminación y visualización fueron desarrolladas con éxito.
    \item \textbf{Trabajo en Equipo:} La práctica requería una división de tareas clara y una colaboración constante para asegurar que todas las partes del programa funcionaran correctamente.
    \item \textbf{Programación Orientada a Objetos:} Se aplicaron principios de programación orientada a objetos, como encapsulación y modularidad, a través de las clases \textit{RedBlackTree} y \textit{Node}.
\end{itemize}

\subsection*{Contribución al Aprendizaje del Concepto}

Los ejercicios contribuyeron significativamente al aprendizaje de los conceptos relacionados con los árboles binarios de búsqueda autobalanceados, por las siguientes razones:

\begin{itemize}
    \item \textbf{Profundización en Árboles Rojo-Negro:} Implementar un Árbol Rojo-Negro ayudó a entender profundamente sus propiedades y el funcionamiento de las rotaciones y correcciones necesarias para mantener el balance del árbol.
    \item \textbf{Algoritmos de Inserción y Eliminación:} Desarrollar los algoritmos de inserción y eliminación en el árbol Rojo-Negro facilitó la comprensión de las complejidades asociadas con el mantenimiento de las propiedades del árbol.
\end{itemize}

\subsection*{Posibles Ventajas y Desventajas del Concepto Visto en la Práctica}

\begin{itemize}
    \item \textbf{Ventajas:}
    \begin{itemize}
        \item \textbf{Eficiencia:} Los árboles Rojo-Negro ofrecen una complejidad de tiempo \(O(\log n)\) para operaciones de búsqueda, inserción y eliminación.
        \item \textbf{Autobalanceo:} Mantienen el árbol balanceado automáticamente, lo cual es crucial para garantizar un rendimiento constante.
    \end{itemize}
    \item \textbf{Desventajas:}
    \begin{itemize}
        \item \textbf{Complejidad de Implementación:} La implementación es más compleja comparada con otros tipos de árboles binarios de búsqueda debido a la necesidad de manejar colores y realizar rotaciones.
        \item \textbf{Sobrecarga Adicional:} La necesidad de mantener información adicional (colores y punteros) introduce una pequeña sobrecarga en términos de memoria.
    \end{itemize}
\end{itemize}

\subsection*{Crítica Constructiva y Propuestas de Mejora}

\begin{itemize}
    \item \textbf{Mejoras en la Práctica:}
    \begin{itemize}
        \item \textbf{Incorporación de Visualización Gráfica:} Agregar una herramienta gráfica para visualizar el árbol Rojo-Negro podría facilitar la comprensión de los conceptos.
        \item \textbf{Más Casos de Prueba:} Incluir una mayor variedad de casos de prueba, especialmente aquellos que cubren casos extremos y bordes, ayudaría a reforzar el entendimiento de las operaciones en el árbol.
    \end{itemize}
    \item \textbf{Propuestas de Modificación:}
    \begin{itemize}
        \item \textbf{División en Módulos Pequeños:} Dividir la práctica en módulos más pequeños podría hacer que los alumnos se concentren en partes específicas del árbol Rojo-Negro antes de abordar la implementación completa.
    \end{itemize}
\end{itemize}

En resumen, la práctica no solo permitió cumplir con los objetivos establecidos, sino que también proporcionó una comprensión profunda de los árboles Rojo-Negro y sus operaciones, destacando tanto sus ventajas como sus desafíos en la implementación.

\end{document}
